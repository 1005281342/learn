<div class="no-mathjax topicTitle">第1章 引言</div><div></div><article id="articleDiv"><div class="mazi-article-content dont-break-out">> 年轻人，通过本书学习编写算法，你将在编程竞赛中大显身手，顺利通过就业面试，卷起袖管大干一场，创造更多的价值。

如今人们仍然存在一种误解，错把程序员当成当代的魔术师。计算机逐渐进入企业和家庭，成为推动世界运行的重要动力。但是，仍有太多人在使用计算机的时候没能掌握足够的知识，充分发挥计算机的能力，来满足自己的需要。懂得编程可以让人们在最大程度上找到解决问题的高效方法。算法和编程成为计算机行业中必不可少的工具。掌握这些技能可以让我们在面对困难时提出有创造力、高效的解决方案。

本书介绍了多种解决某些经典问题的算法技术，描述了问题出现的场景，并用 Python 提出了简单的解决方案。正确地实现算法往往不是一件简单的事情，总需要避开陷阱，也需要应用一些技巧保证算法能够在规定时间内实现。本书在阐述算法实现时附加了重要的细节，以帮助读者理解。

最近几十年，不同级别的编程竞赛在世界范围内展开，推广了算法文化。竞赛考察的问题一般都是经典问题的变种，隐藏在难以破解的谜面背后，让参赛者们一筹莫展。

### 1.1　编程竞赛

在编程竞赛中，参赛者必须在规定时间内解决多个问题。问题的输入称为实例（instance）。举个例子，一个输入实例可以是最短路径问题中图的邻接矩阵。一般来讲，问题会给出一个输入实例和它的输出结果 {1[用于展示思路和代码测试。——译者注]}。参赛者在网上将答案的源代码提交到服务器；之后，服务器的后台进程将编译并执行代码，而后测试对错。对于某些问题，源代码在执行时会被输入多个实例，并一一执行；而对于其他问题，每次执行源代码时，输入都从一个表示实例数量的整数开始。程序必须按顺序读取每个输入实例，解决问题，并输出结果。如果程序能够在指定时间内输出正确结果，那么提交的答案就可以被接受。

![{55%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/001.png)

图 1.1　ACM 竞赛的图标形象地展示了解决问题的步骤。参赛团队每解决一个问题时，就会得到一个吹起的气球

我们无法列出世上所有的编程竞赛名称和竞赛网址。就算有可能，这个列表也会很快过时。但无论如何，我们在这里还是要简单介绍一下最重要的几个编程竞赛。

*   ACM/ ICPC 编程竞赛

    这是历史最悠久的竞赛，由国际计算机协会（ACM）从 1977 年开始举办。竞赛称为“国际大学生程序设计竞赛”（ICPC），以巡回赛的方式进行。比如，巡回赛在法国站的起点是西南欧洲地区竞赛（SWERC）。地区竞赛的前两名有资格进入全球决赛。这个竞赛的特点是每队由 3 位成员组成，共用一台计算机。参赛队在 5 个小时内从 10 个问题中尝试挑战解决尽可能多的问题。排名的第一个依据是答案被接受的数量（答案会被不公开的用例来测试）；排名的第二个依据是解决问题所耗费的时间，耗时以开始解题到提交答案的时长为准。提交一个错误答案会被罚时 20 分钟。

    组成一个优秀团队有很多种方式。一般来说，至少需要一位优秀的程序员和一位优秀的数学家，以及一位擅长不同领域的专家，比如图论、动态规划等。他们需要在承受巨大压力的前提下通力合作。在竞赛中，参赛者可以用 8 磅字体打印 25 页的源代码作为参考。参赛者还可以访问 Java 应用程序编程接口（API）的在线文档，以及 C++ 的在线标准库文档。

*   Google Code Jam 编程竞赛

    国际计算机协会的编程竞赛仅限硕士及以下学历的学生参加，与此不同的是，Google Code Jam 编程竞赛对所有人开放。竞赛每年一度，举办历史较短，而且仅限个人参赛。每个问题通常会包含一系列简单实例，解答这些实例就可以得到一定的分数。同时，问题还包含一系列步骤复杂的实例，这需要真正找到拥有合适复杂度的算法来解决。直到竞赛结束，参赛者才能得知步骤较复杂的实例是否最终被接受了。这个竞赛的优势在于，参赛者在竞赛结束后可以查阅其他参赛者提交的解决方案，这种方式有非常强的指导作用。Facebook Hacker Cup 编程竞赛也采取类似形式。

*   Prologin 编程竞赛

    法国每年为 20 岁以下的学生举办一场 Prologin 编程竞赛。竞赛过程分为三步——在线筛选、地区赛和决赛，以考察参赛者解决算法问题的能力。最终决赛是一场不同寻常的 36 小时竞赛，参赛者需要解决一个人工智能问题。每个参赛者必须编写一个遵循组织者设定规则的游戏程序，然后以循环赛的形式让游戏程序彼此对决，以此来决定参赛者的成绩排名。竞赛官网上 prologin.org 对此有详尽的解释，我们也可以在这里测试自己的算法。

*   France-ioi 编程竞赛

    France-ioi 协会旨在辅助法国初中生和高中生准备国际信息学奥林匹克竞赛。从 2012 年起，协会每年举办“河狸计算机科学竞赛”（竞赛的吉祥物是一只河狸），从初中一年级到高中三年级的学生均可参加。2014 年，全法国有 22.8 万名参赛者。协会官网 france-ioi.org 汇集了 1000 多个有代表性的现象级算法题。

    除了上述竞赛以外，也有大量以筛选求职者为目的举行的编程竞赛。比如 TopCoder 网站不仅进行测试，也会对算法进行详细解释，有时讲解质量极高。如果读者希望训练编程能力，我们特别推荐 Codeforces，这是一个备受竞赛群体推崇的网站，对问题的解释总是清晰而仔细。

#### 1.1.1　线上学习网站

很多网站提供历年各大竞赛真题，并可在线测试答案，供大家学习训练。Google Code Jam 编程竞赛和 Prologin 编程竞赛的官网也提供此类功能。但是，ACM/ICPC 每年的竞赛题目却没有统一归纳。

*   传统的线上训练和裁判网站

    下列网站 [uva.onlinejudge.org](http://uva.onlinejudge.org)、[icpcarchive.ecs.baylor.edu](http://icpcarchive.ecs.baylor.edu) 和 [livearchive.onlinejudge.org](http://livearchive.onlinejudge.org) 总结了大量的 ACM/ICPC 编程竞赛的试题和答案。

*   中国的线上训练和裁判网站

    中国目前有很多线上训练算法能力的网站，比如北京大学的 [poj.org](http://poj.org)、天津大学的 [acm.tju.edu.cn](http://acm.tju.edu.cn) 和浙江大学的 [acm.zju.edu.cn](http://icpcarchive.ecs.baylor.edu)。相对于其他网站，这些网站更注重训练功能。

*   高级语言算法的训练和裁判网站

    [spoj.com](http://spoj.com)（Sphere Online Judge）网站接受用户使用更多种编程语言提交问题的解决方案，其中包括 Python。

在本书配套网站 [tryalgo.com](http://tryalgo.com) 中，读者可以找到应用本书各章讲解的知识和技巧来解决的问题，在实践中检验从书中学到的算法知识。

编程竞赛主要使用的编程语言是 C++ 和 Java 语言。Google Code Jam 编程竞赛接受所有编程语言，因为解题过程是参赛者在本地开发环境中完成的。除此之外，上面提到的线上训练和裁判网站 SPOJ 也接受 Python 语言的解答方案。为了解决因编程语言不同而导致的程序执行时间的差异问题，线上训练和裁判网站对使用不同编程语言的解答方案给出了不同的时间限制。但是，这种平衡策略并不总是准确的，而且，用 Python 语言完成的解题方案经常不能被正确执行。我们希望这种情况在未来几年能够有所改善。某些线上训练和裁判网站仍在使用 Java 语言的老版本，导致有些很实用的类无法使用，如 Scanner 类。读者在使用这些网站的时候，应当注意版本兼容问题。

#### 1.1.2　线上裁判的返回值

当一段代码被提交给线上训练和裁判网站的时候，会被一系列不公开的测试用例测试，测试结果和一段简要的返回值会反馈给提交者。返回代码有以下几种。

*   Accepted ：已接受状态

    你提交的代码在指定时间内给出了正确的结果，祝贺你！

*   Presentation Error ：展示错误

    程序基本能够被接受，但显示了过多或过少的空格或换行符。这种返回码很少出现。

*   Compilation Error ：编译错误

    你的程序在编译过程中出了错。一般来说，当你点击这条返回码的时候，就能得到错误的详细信息。你应当比较一下，裁判和自己使用的编译器版本是否有所不同。

*   Wrong Answer ：错误答案

    重新读一遍题吧，你肯定漏掉了什么细节。你是否确定已经检查了所有的边界条件？你是否在代码中遗留了调试代码？

*   Time Limit Exceeded ：执行超时

    你的解答方案可能没有达到足够优化的实现效率，或者代码的某个角落里藏着一个死循环。检查循环变量，确保循环能够终止。使用一个大规模的复杂测试用例在本地执行测试，确保你的代码性能。

*   Runtime Error ：运行时错误

    一般来说，这种错误源于分母为 0 的除法运算、数组下标越界，或者对一个空的堆执行了 `pop()` 方法。其他情况也会产生这条错误提示，比如在使用 Java 语言的解答方案中使用了 `assert` 断言，这种方式在编程竞赛中一般是不被接受的。

除了以上有明确意义的返回代码，没有返回代码的情况也能够或多或少地提供一些信息，帮助查找错误。以下是一个 ACM/ICPC/SWERC 竞赛中的真实案例。在一道关于图的题目中，明确指出了输入数据是连通图，但某个参赛团队对此信息不太确定，于是编写了一个测试连通性的方法：当这个方法返回 `true` 结果，即输入为连通图时，程序会进入死循环（返回执行超时错误）；而当这个方法返回 `false` 结果，即输入为非连通图时，程序会执行一个分母为 0 的除法（返回运行时错误）。这种方法可以帮助参赛者探测到某些测试用例输入的图并不是题目中的连通图，从而避免错误。{2[这种方法的目的是在程序中故意留一些缺陷，从而通过返回值来猜测输入数据的具体情况。 ——译者注]}

### 1.2　我们的选择：Python

鉴于 Python 编程语言的可读性和使用的简易性，本书选用它来描述算法。在工业领域，Python 通常用于制作程序的原型。Python 也用于如 SAGE 这类重要的项目系统，因为其中的核心内容大多用实现速度快很多的语言编写，如 C 或 C++。

现在我们说说 Python 编程语言的一些细节。在 Python 中有四个基本数据类型：布尔型、整型、浮点型和字符串。与其他大多数的编程语言不同，Python 中的整数不受数字占用的二进制位数限制，而使用高精度计算方式。

Python 中的高级数据类型包括字典（dictionary）、列表（list）和元组（tuple）。列表和元组的区别是，元组是不可变数据，因此可以用作字典中键值对数据的键。

网络上有很多 Python 的入门教程，如官网 python.org。David Eppstein 创建了一个名为“Python 算法和数据结构”（PADS）的元件库，其中也有很好的讲解。

在编写本书代码的过程中，我们遵循了 PEP8 规范。该规范细致地规定了空格的使用方法、变量命名规则，等等。我们建议读者也遵循上述规范。

*   Python 2 还是 Python 3 ？

    Python 3.x 版本已经于 2008 年发布。但直到今天，由于仍有大量的类库没有迁移到 Python 3.x，使得许多开发工作还继续停留在 Python 2.x 版本。尽管如此，我们仍然选择使用 Python 3.x 来实现算法。Python 2.x 和 Python 3.x 对本书中代码的主要影响在于 print 语句的使用方式，以及整数除法的使用方式。在 Python 3.x 中，对于两个整数 _a_ 和 _b_，表达式 _a_/_b_ 会返回除法的浮点型的商，表达式 _a_//_b_ 返回的则是两者的欧几里得商，即商的整数部分。`print` 的用法区别在于，在 Python 2.x 中 `print` 是语句，而在 Python 3.x 中 `print()` 是需要使用括号包围的参数来调用的函数。

    如果程序运行存在性能问题，可以考虑使用 pypy 或 pypy3 解释器来执行，因为这都是实时编译器。也就是说，Python 代码会先被翻译为机器码，然后才被干净而迅速执行。但 pypy 的弱点在于它仍处在开发过程中，很多 Python 类库尚无法支持。

*   无穷

    Python 使用高精度计算方式进行计算，而不用二进制位数来限制整数的大小。所以，在 Python 语言中不存在哪个数可以指代正无穷大或负无穷大的值。但对于浮点数，我们可以用 `float('inf')` 和 `float('-inf')` 来指代正、负无穷大。

*   一些建议

    Python 的初学者在复制列表数据时经常犯一个错误。在下面的例子里，列表 B 只是一个指向列表 A 的引用。对 B[0] 的修改同样会修改 A[0]。

        A = [1, 2, 3]
        B = A
    `</pre>
    当复制一个 A 的独立副本时，我们可以使用以下语法格式：
<pre>`A = [1, 2, 3]
     B = A[:]
    `</pre>
    语句 `[:]` 用以复制一个列表。我们也可以复制一个去掉首元素的列表 A[1:]，或者去掉末尾元素的列表 A[:-1]，或者逆序的列表 A[::-1]。举例来说，下面的代码会生成一个所有行完全相同的矩阵 M，而对 M[0][0] 元素的修改会导致第一列所有元素被修改。
<pre>`M = [[0] * 10] * 10

    我们可以用下面两种正确的方式来初始化一个这样的矩阵：

<pre>
    M1 = [[0] * 10 for _ in range(10)]
    M2 = [[0 for j in range(10)] for i in range(10)]
    </pre>

操作矩阵的简单方式是使用 numpy 模块，但我们在本书中不使用第三方类库，以便让程序代码能更方便翻译成 Java 或 C++ 代码。

另一个典型错误经常发生在使用 `range` 语句时。比如，下面的代码会顺序处理列表 A 中 0 至 9 号元素（包括 0 号和 9 号元素）：

<pre>
for i in range(0, 10):            # 包括 0，不包括 10
    treat(A[i])
</pre>

如果想逆序处理上述元素，仅反转参数是不够的。语句 `range(10, 0, -1)` 中的第三个参数代表循环的步长，语句会导致被处理元素中的 10 号元素被包含在内，而 0 号元素被排除在外。因此需要用以下方式来处理：

<pre>
for i in range(9, -1, -1):        # 包括 9， 不包括 -1
   treat(A[i])
</pre>

### 1.3　输入输出

#### 1.3.1　读取标准输入

在大部分编程竞赛的题目中，源数据都需要从标准输入设备来读取，并把输出显示到标准输出设备上。如果输入文件名叫 `test.in`，你的程序名叫 `prog.py`，那就可以在控制台执行以下命令，将输入文件的内容重定向到你的程序：

<pre>
python prog.py &lt; test.in
</pre>
> 一般来说，在 Mac OS X 系统中，控制台可以用 Command + 空格，呼出 SpotLight 搜索后键入 Terminal 来打开；在 windows 系统中，使用“开始 – 执行 – cmd”；在 Linux 系统中，使用快捷键 Alt-F2 {3[使用组合快捷键是个好习惯。在 Windows 环境下，Windows 7 和 windows XP 系统都可以使用上述方式，而在 Windows 8、Windows 10 和 Windows Server 环境下，建议使用 Windows+R 组合键呼出“运行命令”窗口，再输入 cmd 打开控制台，或在 Windows 8 和 Windows 10 环境下，直接按 Windows 键打开“开始”屏幕，输入 cmd 后回车，也可以快速打开控制台。——译者注]}。

如果你想把程序的输出记录到名为 `test.out` 的输出文件中，使用的命令格式如下：

<pre>
python prog.py &lt; test.in > test.out
</pre>

小技巧，如果你想把输出写入文件 `test.out`，同时还要显示在屏幕上，可以使用以下命令（注意，`tee` 命令在 Windows 环境下默认是不存在的）：

<pre>
python prog.py &lt; test.in | tee test.out
</pre>

输入数据文件可以使用 `input()` 语句按行读取。`input()` 语句把读取到的行用字符串的形式返回，但不会返回行尾的换行符 {4[根据操作系统的不同，换行符可能是 \r 或 \n，或二者皆有，但使用 `input()` 输入的时候不需要考虑这个问题。注意在 Python2.x 中，`input()` 方法的行为是不同的，同样，应当使用等价的 `raw_input()` 方法。]}。在 sys 模块中有一个类似的方法 `stdin.readline()`，这个方法不会删除行尾的换行符，但根据我们的经验，它的执行速度是 `input()` 语句的 4 倍。

如果读取到的行包含的应当是一个整数，我们使用 `int` 方法进行类型转换；如果是一个浮点数，我们使用 `float` 方法。当一行中包含多个空格分隔的整数时，我们首先使用 `split()` 方法把这一行拆分成独立的部分，然后用 `map` 方法把它们全部转换成整数。举例来说，当用空格分隔的两个整数——高度和宽度，需要在同一行内被读取时，可以使用以下命令 {5[以下命令中使用了 `map` 及管道概念。——译者注]} ：

<pre>
import sys
height, width = map(int, sys.stdin.readline().split())
</pre>

如果你的程序在读取数据时遇到性能问题，根据我们的经验，可以仅使用一次系统调用，把整个输入文件读入，速度即可提升 2 倍。在下列语句中，假设输入数据中只有来自多行输入的整数， `os.read()` 方法的参数 0 表示标准输入流，常量 M 必须是一个大于文件大小的限值。比如，文件中包含了 10<sup>7</sup> 个大小在 0 至 10<sup>9</sup> 之间的整数，那么每个整数最多只能有 10 个字符，而两个整数中间最多只有两个分隔符（\r 和 \n，即回车和换行），我们可以选择 M = 12·10<sup>7</sup> 。

<pre>
import os
inputs = list(map(int, os.read(0, M).split()))
</pre>

*   例子：读取三个矩阵 A、B、C，并测试是否 AB = C

    在此例子中，输入格式如下：第一行包含一个唯一的整数 _n_，接下来的 3_n_ 行，每行包含 _n_ 个被空格分隔的整数。这些行代表三个 _n_×_n_ 矩阵 A、B、C 内包含的所有元素。例子的目的是测试矩阵 A×B 的结果是否等于矩阵 C。最简单的方法是使用矩阵乘法的解法，复杂度是 _O_(_n_<sup>3</sup>)。但是，有一个可能的解法，复杂度仅有 _O_(_n_<sup>2</sup>)，即随机选择一个向量 _x_，并测试 A(B_x_) = C_x_。这种测试方法叫作 Freivalds 比较算法（见参考文献 [8]）。那么，程序计算出的结果相等，而实际上 AB ≠ C 的概率有多大呢？如果计算以 _d_ 为模，错误的最大概率是 1/_d_。这个概率在多次重复测试后可以变得极小。以下代码产生错误的概率已经低至 10<sup>-6</sup> 量级。

<pre>
from random import randint
from sys import stdin

def readint():
    return int(stdin.readline())

def readarray(typ):
    return list(map(typ, stdin.readline().split()))

def readmatrix(n):
    M = []
    for _ in range(n):
        row = readarray(int)
        assert len(row) == n
        M. append(row)
    return M

def mult(M, v):
    n = len(M)
    return[sum(M[i][j] * v[j] for j in range(n)) for i in range(n)]

def freivalds(A, B, C):
    n = len(A)
    x = [randint(0, 1000000) for j in range(n)]
    return mult(A, mult(B, x)) == mult(C, x)

if __name__ == " __main__ ":
    n = readint()
    A = readmatrix(n)
    B = readmatrix(n)
    C = readmatrix(n)
    print(freivalds(A, B, C))
</pre>

#### 1.3.2　显示格式

程序的输出必须使用 `print` 命令，它会根据你提供的参数生成一个新的行。行尾的换行符可以通过在参数中传递 `end="` 取消掉。为显示指定小数位数的浮点数，可以使用 % 运算符，方法为“格式 % 值”。第 _i_ 个占位符会被值列表中的第 _i_ 个值替换。以下例子显示了一行格式类似“Case #1: 51.10 Paris”的字符串：

<pre>
print("Case #%i: %.02f %s" % (testCase, percentage, city))
</pre>

在上面例子中，%i 被整型变量 `testCase` 的值所替换，%.02f 被浮点型变量 `percentage` 的值所替换并保留两位小数，%s 被字符串型变量 `city` 的值所替换。

### 1.4　复杂度

要想写出高效率的程序，必须先找到一个具有合适复杂度的算法。复杂度取决于运算时间和输入数据大小之间的关系。我们用朗道表达式（大 _O_ 符号）来表示不同算法的复杂度。假设输入数据或参数的长度为 _n_，且算法的运算时间随 _n_<sup>2</sup> 变化，那么我们就说这个算法的复杂度是 _O_(_n_<sup>2</sup>)。

对于两个正值函数 _f_ 和 _g_，如果存在正实数 _n_<sub>0</sub> 和 _c_，对于所有 _n_ ≥ _n_<sub>0</sub> 都满足 _f_(_n_) ≤ _c_·_g_(_n_)，则我们借此定义函数之间的关系，并简记为 _f_∈_O_(_g_)。由于滥用符号，也有人写做 _f_ = _O_(_g_)。这种记法能够把函数 _f_ 中的乘法常量和加法常量抽象出来，体现出函数运算时间相对于参数长度的增长速度。

同样，对于常量 _n_<sub>0</sub> 和 _c_（_c_ ＞ 0），如果对于所有 _n_ ≥ _n_<sub>0</sub> 都能够满足 _f_(_n_) ≥ _c_·_g_(_n_)，则记作 _f_∈Ω(_g_)。如果 _f_∈_O_(_g_) 且 _f_∈Ω(_g_)，则记作 _f_∈Θ(_g_)，它表示 _f_ 和 _g_ 函数拥有相同的时间复杂度。

当 _c_ 是一个常量且算法的复杂度是 _O_(_n<sup>c</sup>_) 的时候，我们说这个算法的复杂度和 _n_ 成多项式时间关系。当一个问题存在一种算法解，而且解的复杂度是多项式时间的时候，该算法就是一个需要多项式时间解决的问题。这类问题有一个专门的名字叫作 P 问题 {6[在计算复杂度理论中，P 是在复杂度类问题中可于决定性图灵机以多项式量级或称多项式时间求解的决定性问题。——译者注]}。遗憾的是，不是所有的问题都存在多项式时间解。还有大量问题，人们尚未找到任何能够在多项式时间内解决的算法。

其中一个问题是布尔可满足性问题（_k_-SAT）：给定 _n_ 个布尔型变量和 _m_ 条语句，每条语句包含 _k_ 个符号（每个符号代表一个变量或其逆值变量），是否有可能为每个变量赋一个布尔值（真或假），使得每条语句包含至少一个值为真的变量？（SAT 是布尔可满足性问题中语句对符号数量没有限制的版本。）每一个单独问题 {7[_k_ 取不同值的时候。——译者注]} 的特殊性在于，我们能够在多项式时间内通过评估所有条件，验证一个潜在的解（变量赋值）能否满足以上所有限制。当以上条件被满足的时候，这类问题有个专门的名字叫作 NP 问题 {8[非定常多项式时间复杂性类，包含了可以在多项式时间内，对于一个判定性算法问题的实例，一个给定的解是否正确的算法问题。——译者注]}。我们可以很容易在多项式时间内解决 1-SAT，因此 1-SAT 问题属于 P 问题。2-SAT 同样也属于 P 问题，我们将在 6.10 节验证它。但从 3-SAT 开始，我们就不确定了。我们只知道解决 3-SAT 问题的难度至少和 SAT 问题的难度相当。

若恰好 P ⊂ NP，直观看来，如果我们能找到一个多项式时间复杂度的解，那就一定可以找到一个非定常多项式时间复杂度的解。人们认为 P ≠ NP，但目前这个推测仍然得不到证实。在证实之前，研究者们把 NP 问题简化，把问题 A 的多项式时间算法解转化为问题 B 的解。如此一来，如果 A 问题属于 P 类，那么 B 问题也同样属于 P 类——A 问题的难度和 B 问题的难度“至少是相同的”。至少和 SAT 难度相同的问题集合构成了一个问题的类别，即 NP 困难问题。它们中有一部分既是 NP 困难问题，又属于 NP 问题，那么这些问题则属于 NP 完全问题。无论是谁，只要能在多项式时间内解决其中一个问题，就可以解决所有其他问题。而这个人也会被历史铭记，同时得到一百万美元的奖金。目前，为了在可接受的时间内解决这些问题，挑战者必须专注于那些有助于解决问题的方向和领域（如图的平面性问题），或者让程序能用稳定的概率返回结果，或者提出接近最优解的解决方案。幸运的是，那些在编程竞赛中可能遇到的问题总体来说都是多项式时间复杂度问题的。{9[如果读者对算法复杂度相关问题感兴趣，推荐阅读：《可能与不可能的边界：P/NP 问题趣史》，人民邮电出版社，2014 年。——编者注]}

在个人编程竞赛中，参赛者的程序必须在几秒钟内给出结果，这只留给处理器执行上千万或上亿次运算的时间。表 1.1 给出了针对不同的输入数据长度，以及在 1 秒钟内给出结果的算法的可接受时间复杂度标准。要注意，这些数字取决于编程语言 {10[大致上，C++ 比 Java 语言快 2 倍时间，比 Python 快 4 倍时间。]} 和执行程序的硬件设备，以及要执行的运算类型，如整数运算、浮点数运算或调用数学函数。

表 1.1

<table>
<thead>
<tr>
<th>输入数据长度</th>
<th>可接受的复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000000</td>
<td>O(n)</td>
</tr>
<tr>
<td>100000</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>1000</td>
<td>O(n<sup>2</sup>)</td>
</tr>
</tbody>
</table>

我们请读者用简单程序做一个实验，测试用不同的 _n_ 值做 _n_ 次乘法所需要的运算时间。我们坚持认为，在朗道表达式中，那些隐藏常量值也可能非常重要，而且有时在实践中，算法的渐进时间复杂度越大，就越有可能成功。举个例子，当计算两个 _n_×_n_ 阶矩阵乘法的时候，贪婪算法需要 _O_(_n_<sup>3</sup>) 次运算，然而 Strassen 发现了一个只需要 _O_(_n_<sup>2.81</sup>) 次运算的递归算法（见参考文献 [26]）。但对于实际要进行的矩阵运算，贪婪算法显然更加有效率。

在 Python 中，在列表中添加一个元素所需要的时间是一个常数，同样，访问一个指定下标的列表元素所需要的时间也是一个常数。新建一个列表的 L[_i_ :_j_ ] 子列表所需要的时间是 _O_(max{1, _j_-_i_ }){11[跟子列表本身的长度有关。——译者注]}。Python 语言中的字典型数据通过散列表（hash table）来表示和存储，在最坏情况下，访问一个键所需要的时间是线性的（由字典中键的数量决定），但实际上，访问时间一般是常数。然而，这个常数时间是不能忽略的，所以，如果字典的键值是 0 到 _n_-1 的整数，最好使用列表性能。

对于某些数据结构，我们使用分摊时间复杂度。比如在 Python 中，一个列表在内部是用表格来展现的，并有一个大小属性。当用 `append` 方法将一个新元素加入列表的时候，它会被加入到表格的最后一个元素之后，列表大小属性加 1。如果表格的容量不足以添加新元素，则会分配一个内存空间是原表格大小 2 倍的新表格，并把原表格内容复制进来。同样，当对一个空列表连续执行 _n_ 次 `append` 命令时，每次执行时间有时是常量，有时是与列表大小相关的线性值。但这些 `append` 方法的执行时间仍然在 _O_(_n_) 级别，因为每次执行操作可以分摊一个 _O_(1) 级别的常量时间。

### 1.5　抽象类型和基本数据结构

我们将首先讲述高效编程的核心内容——程序解决问题的基础，即数据结构。

抽象类型是关于一系列对象的规范，它归纳了对象可以取的值、可以执行的操作以及操作的具体内容。我们也可以把一个抽象类型理解为对象的统一规格。

数据结构是根据统一规格的定义，为高效处理特定数据而总结出的具体数据组织方式。因此，我们可以使用一个或多个数据结构来实现一个抽象类型，并设定每个操作的时间复杂度和所需内存。如此一来，根据操作被执行的频率，我们会选择某一种抽象类型的实现方式来解答不同问题。

为了更好地编写程序，必须掌握编程语言和标准库所提供的数据结构。在下面几节中，我们来讲解一下竞赛中最实用的数据结构。

#### 1.5.1　栈

栈（stack）是把元素组织起来并提供如下操作的对象（图 1.2）：测试一个栈是否为空，在其顶部添加一个元素（入栈），从顶部访问并删除一个元素（出栈）。Python 语言的基本类型列表（list）实现了栈。我们使用 `append(element)` 方法执行入栈操作，使用 `pop()` 方法执行出栈操作。如果一个列表被用于布尔运算，比如一个 `if` 或 `while` 语句中的条件测试，语句当且仅当它非空的时候值为真。此外，其他所有实现了 `__len__` 方法的对象也是如此。以上所有操作需要的时间都是一个常数。

![{%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/003.png)

图 1.2　Python 语言中三种主要的访问序列数据结构

#### 1.5.2　字典

字典能采用表格和下标的方式把键和值关联起来。其内部运行方式以散列表结构为基础；散列表结构使用散列算法把元素与表中的某个下标关联，并在多个元素与同一个下标关联的时候实现冲突处理机制。在最好的情况下，字典的读、写操作时间都是常数。但在最坏的情况下，所需时间是线性的，因为系统必须顺序访问一系列键和值，以便处理冲突 {12[顺序访问所有拥有同一个下标或散列值的键，直到找到需要的对象。——译者注]}。在实际应用中，最坏的情况很少发生。在本书中，我们总体上都假设访问一个字典元素的时间是常数。如果键值的形式为 0, 1,…, _n_-1，我们通常建议使用简单的表结构而不是字典，令程序效率更高。

#### 1.5.3　队列

队列与栈类似，差别仅在于向队列里添加元素时，元素被加到尾部（入队），而提取元素时则从队列头部开始（出队）。这种机制也称作 FIFO（first in, first out，先进先出），就像排队一样；而栈则被称作 LIFO（last in, first out，后进先出），就像垒一堆盘子一样。

在 Python 的标准库中，有两个类实现了队列。第一是 `Queue` 类，这是一个同步实现，意味着多个进程可以同时访问同一个对象。由于本书的代码不涉及并发机制，我们不推荐使用这个类，因为它在执行同步的时候使用的信号机制会拖慢执行速度。第二是 `Deque` 类（Double Ended Queue，即双向队列），除了提供标准方法，即在尾部使用 `append(element)` 添加元素和在头部使用 `popleft()` 提取元素之外，它还提供了额外方法，用于在队列头部使用 `appendleft(element)` 添加元素和在尾部使用 `pop()` 提取元素。我们把这种队列称作双向队列。这种更复杂的数据结构将在 8.2 节详细说明：在路径权重是 0 和 1 的图中查找最短路径算法中，这种结构非常有用。

我们推荐使用 `Deque` 类。但为了举例说明，以下代码展示了如何使用两个栈实现一个队列的方式。一个栈作为队列头部，用于提取元素，另一个栈作为队列尾部用于插入元素。当作为头部的栈为空的时候，它会与作为尾部的栈相互替换。通过 `len(q)`，`__len__` 方法能获取队列 q 中的元素数量，并通过 `if q` 测试队列是否为空。幸运的是，这些操作所需时间都是常数。

<pre>
class OurQueue:
    def __init__(self):
        self.in_stack = []           # 队列的尾部
        self.out_stack = []          # 队列的头部

    def __len__(self):
        return len(self.in_stack) + len(self.out_stack)

    def push(self, obj):
        self.in_stack.append(obj)

    def pop(self):
        if not self.out_stack:       # 队列头为空
            self.out_stack = self.in_stack[::-1]
            self.in_stack = []
        return self.out_stack.pop()
</pre>

#### 1.5.4　优先级队列和最小堆

优先级队列是一个抽象类型数据，能够添加元素，并取出键数字最小的那个元素。在生成哈夫曼编码（见 10.1 节）和在图中找到两个点的最短路径（见 8.3 节 Dijkstra 算法）时，利用优先级队列对一个数组进行排序（用堆排序算法），十分有用。优先级队列通常是通过堆的方式来实现的，堆的数据格式类似于一棵树。

*   满二叉树和完全二叉树

    如果一棵二叉树的所有叶子节点与根节点之间的距离都相同，则二叉树被称作满二叉树。如果一棵二叉树的所有叶子节点最多位于两层，所有浅层叶子节点全满，而最深层的叶子节点集中在最左边，这就是一棵完全二叉树。使用数组可以很容易表示这样的树形结构（图 1.3）。这棵树下标为 0 的元素被忽略，根节点的下标是 1，节点 _i_ 的两个子节点是 2_i_ 和 2_i_+1。利用简单的计算即可操作和遍历这棵树。在第 10 章中，有其他表示树形结构的数据结构。

    ![{95%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/004.png)

    图 1.3　一棵使用数组结构表示的完全二叉树

*   优先级队列和堆

    堆（heap）是一个能检查元素优先级的反转树状结构。假如每个节点的键值（也就是优先级）比其子节点小，那这就是一个最小堆。最小堆根节点的键值一定是堆中最小的一个。同样也存在最大堆的概念，即每个节点的键值都比其所有子节点的键值要大。

    人们通常更感兴趣的是二叉堆，即完全二叉树。这类数据结构能在对数时间内提取最小元素和插入新元素。总的来说，这里所讲的是有一定顺序关系的元素集合。堆也能更新一个元素的优先级，在使用 Dijkstra 算法寻找一条向顶端的最短路径时，这个操作非常有用。

    在 Python 语言中，堆排列是用 `heapq` 模块实现的。这个模块提供了把数组转化成堆的方法，即 `heapify(table)`。而转化后的数组仍是前面提到的完全二叉树，唯一的区别是其根节点下标为 0 的元素非空。这个模块同样可以插入一个新元素，即 `heappush(heap, element)`，以及抽出最小元素，即 `heappop(heap)`。

    相反，`heapq` 模块不能修改堆中的元素值，而这个操作在 Dijkstra 算法中可以优化时间复杂度。因此，我们推荐下面更完整的实现方式。

    实现的细节

    相关结构包含了 heap 数组结构，储存着一个纯粹意义上的堆；结构中还包含一个 `rank` 字典，用于查找堆中元素的下标。主要操作是 `push` 和 `pop`。当用 `push` 方法插入一个新元素时，元素被当作堆中最后一个叶子节点加入，然后，堆会根据其排序规则重新组织。使用 `pop` 方法可以提取最小元素，根节点被堆的最后一个叶子节点所替换，然后堆会再次根据自身规则重新组织。图 1.4 展示了这一过程。

    ![{98%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/005.png)

    图 1.4　`pop` 操作移除并返回堆的数值 2，并用末端的叶子节点 15 替换。然后 `down` 操作执行一系列交换，将 15 移动到符合堆规则的位置{13[图中是一个最小堆，其中每个节点的键值一定小于其所有子节点，因此会根据此规则执行替换。 ——译者注]}

    操作 `__len__` 返回堆的元素数量。这个操作通过 Python 隐式地把一个堆转换成一个布尔值，比如，在堆 h 非空的时候，可以将 `while h` 这样的判断语句作为继续循环的条件。

    堆的平均复杂度是 _O_(log_n_)，但在最差情况下，由于使用了字典 `rank`，复杂度会增加到 _O_(_n_)。

<pre>
class OurHeap:
    def __init__(self, items):
    self.n = 0
    self.heap = [None]          # index 0 会被替换
    self.rank = {}
    for x in items :
        self.push(x)

    def __len__(self):
        return len(self.heap) - 1

    def push(self, x):
        assert x not in self.rank
        i = len(self.heap)
        self.heap.append(x)     # 添加一个新的叶子节点
        self.rank[x] = i
        self.up(i)              # 保持堆排序

    def pop(self):
        root = self.heap[1]
        del self.rank[root]
        x = self.heap.pop()     # 移除最后一个叶子节点
        if self:                # 堆非空
            self.heap[1] = x    # 移动到根节点
            self.rank[x] = 1
            self.down(1)        # 保持堆排序
        return root
</pre>

堆的重新组织通过 `up(i)` 和 `down(i)` 操作实现：当一个下标为 _i_ 的元素比其父节点小，此时用 `up` 操作；当元素比其子节点大，则用 `down` 操作。因此，`up` 操作让某节点完成与其父节点的一系列交换，直到满足堆的规则。而 `down` 操作的效果类似，用于节点及其子节点的交换。

<pre>
def up(self, i):
    x = self.heap[i]
    while i > 1 and x &lt; self.heap[i // 2]:
        self.heap[i] = self.heap[i // 2]
        self.rank[self.heap[i // 2]] = i
        i //= 2
    self.heap[i] = x      # 找到了插入点
    self.rank[x] = i

def down(self, i):
    x = self.heap[i]
    n = len(self.heap)
    while True:
        left = 2 * i      # 在二叉树中下降
        right = left + 1
        if right &lt; n and \
           self.heap[right] &lt; x and self.heap[right] &lt; self.heap[left]:
            self.heap[i] = self.heap[right]
    self.rank[self.heap[right]] = i              # 提升右侧子节点
    i = right
        elif left &lt; n and self.heap[left] &lt; x:
            self.heap[i] = self.heap[left]
            self.rank[self.heap[left]] = i       # 提升左侧子节点
            i = left
        else:
            self.heap[i] = x      # 找到了插入点
            self.rank[x] = i
            return

def update(self, old, new):
    i = self.rank[old]            # 交换下标为 i 的元素
    del self.rank[old]
    self.heap[i] = new
    self.rank[new] = i
    if old &lt; new:                 # 保持堆排序
        self.down(i)
    else:
        self.up(i)
</pre>

#### 1.5.5　并查集

*   定义

    并查集（Union-find）这种数据结构存储了一系列 V 字形集合（分片），并能完成一些指定操作。这些操作在动态数据结构中也被称为查询。

    *   `find(v)` 返回元素 _v_ 所在集合内的一个特定元素。如果想检验元素 _u_ 和元素 _v_ 是否在同一个集合中，只需比较 `find(u)` 和 `find(v)`。
    *   `union(u, v)` 合并分别包含 _u_ 和 _v_ 的两个集合。
*   应用

    这种数据结构主要应用于检测图的元素连通性（见 6.6 节）。每次添加路径都调用一次 `union` 和 `find`，以此测试两个顶点是否在同一个集合中。并查集还可用于 Kruskal 算法对最小生成树的判断（见 10.4 节）。

*   数据结构对每个查询所需的时间基本为常量

    我们把集合中的有向树元素指向一个特定元素（图 1.5）。每个 _v_ 元素有一个指向树中更高层级节点的引用 parent[_v_]。根节点 _v_ 是集合的特定元素，在 parent[_v_] 中用一个特殊值来标注，我们可以选择 0 或 -1，或在值相关情况下选择 _v_ 元素本身。整个元素的大小保存在数组 length[_v_] 中，其中 _v_ 是特定元素。在这个数据结构中有两个概念。

    1.  当朝向根节点遍历一个元素的时候，我们将借机压缩路径；也就是说，把遍历路径上的所有节点直接挂在根节点上。
    2.  当执行合并操作 `union` 的时候，我们把序列最低的树挂在阶最高的树的根节点上。一棵树的阶指的是在树没有被压缩时，本应有的深度。

![{%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/006.png)

图 1.5　左图：并查集结构包含两个集合 {7, 8, 2} 和 {2, 3, 4, 5, 6, 9, 10, 11}。右图：当执行操作 `find(10)` 时，指向根节点的路径上的所有节点都直接指向根节点 5。这种机制对将来执行节点的 `find` 操作有加速作用

于是我们得到如下代码：

<pre>
class UnionFind :
    def __init__(self, n):
        self.up = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.up[x] == x:
            return x
        else:
            self.up[x] = self.find(self.up[x])
            return self.up[x]

    def union(self, x, y):
        repr_x = self.find(x)
        repr_y = self.find(y)
        if repr_x == repr_y:          # 已在同一个集合中
            return False
        if self.rank[repr_x] == self.rank[repr_y]:
            self.rank[repr_x] += 1
            self.up[repr_y] = repr_x
        elif self.rank[repr_x] > self.rank[repr_y]:
            self.up[repr_y] = repr_x
        else:
            self.up[repr_x] = repr_y
        return True
</pre>

可以证明，对于一个大小为 _n_ 的集合，任何 _m_ 次 `union` 或 `find` 操作所需要的时间复杂度都是 _O_((_m_+_n_) α(_n_))，其中 α 是 Ackermann 函数的反函数，一般可以视为常量 4。

### 1.6　技术

#### 1.6.1　比较

在 Python 语言中，元组比较采用字典序。例如，这种方式能找到一个数组中的最大元素，同时还能找到它的下标，当有重复值的时候取最大的下标。

<pre>
max((tab[i], i) for i in range(len(tab)))
</pre>

举例来说，为了找到一个数组中的多数元素（majority element），我们可以用字典来统计每个元素的出现次数，并用以上代码来选择其中的多数元素。这种实现方式的平均时间复杂度是 _O_(_nk_)；而在最差情况下，由于使用了字典，时间复杂度是 _O_(_n_<sup>2</sup>_k_)。其中 _n_ 是给定输入的单词数量，而 _k_ 是一个单词的最大长度。

这里顺便讲一下，字典数据类型的使用方式存储键值对 (key, value)。一个空字典用 `{}` 来表示。测试一个字典中是否存在键的方法是 `in` 和 `not in`。下面代码中的 `for` 循环可以遍历字典中所有的键来完成查找。

<pre>
def majority(L):
    compute = {}
    for word in L:
        if word in compute:
            compute[word] += 1
        else:
            compute[word] = 1
    valmin, argmin = min((-compute[word], word) for word in compute)
    return argmin
</pre>

#### 1.6.2　排序

Python 语言中包含 _n_ 个元素的数组排序的时间复杂度是 _O_(_n_log_n_)。排序分为以下两种。

*   `sort()` 排序：这个方法会直接修改被排序的列表内容，称为“原地”修改。
*   `sorted()` 排序：这个方法会返回相关列表的一个排好序的副本。假设包含 _n_ 个整数的数组 _L_，我们想在其中找到两个差值最小的整数。为了解决这个问题，可以先对数组 _L_ 进行排序，然后对其进行遍历，最终找到数值最接近的两个整数。使用 `min` 方法结合字典排序法，可以找到集合中的多组整数对。同样，`valmin` 变量包含着数组 _L_ 中两个连续元素的最小差值（即数组 _L_ 中两个值最近的数的差值）；`argmin` 变量则是这两个数中较大一个数的下标。
<pre>
def closest_values(L):
    assert len(L) >= 2
    L.sort()
    valmin, argmin = min((L[i] - L[i - 1], i) for i in range(1, len(L)))
    return L[argmin - 1], L[argmin]
</pre>

在最差情况下，对 _n_ 个元素排序所需的时间复杂度是Ω(_n_log_n_)。为了证明这一点，我们假设有一个包含 _n_ 个不同整数的数组。算法必须在 _n_! 种可能序列中找到一种排好的序列。每次比较会返回两种可能中的一个值（更大或更小），并把结果空间切分为两部分。最终，在最坏情况下，需要 [log<sub>2</sub> (_n_!)] 次比较才能找到这个特定序列，从而得到复杂度的下限Ω(log(_n_!)) = Ω(_n_log_n_)。

*   变种

    在某些情况下，我们可以在 _O_(_n_) 时间内对一个包含 _n_ 个整数的数组进行排序。比如，一个数组内的所有整数全部在 0 到 _cn_ 范围内，其中 _c_ 是任意实数。我们只需遍历输入，在一个大小为 _cn_ 的数组 count 中计算每个元素的出现次数；然后使用下标降序遍历 count，就可以得到一个包含了 0 到 _cn_ 的值的输出数组。这种排序方法称为“计数排序”（counting sort）。

#### 1.6.3　扫描

众多几何学问题都可以用扫描算法来解决。许多关于区间（interval），也就是一维几何对象的问题也一样。扫描算法旨在从左往右地遍历输入元素，并对每个遇到的元素做特定处理。

*   例子：区间交叉

    对于给定的 _n_ 个区间 [_l<sub>i</sub>_ , _r<sub>i</sub>_ )，其中 _i_ = 0,…, _n_-1，我们希望找到一个 _x_ 值，它被最多的区间包括。以下是一个时间复杂度为 _O_(_n_log_n_) 的解决方案。我们把所有极限值一起排序，然后用一个假想的指针 _x_ 从左到右遍历这些极限值；再用一个计数器 c 来记录只看到起始值却看不到终止值的区间的数量，于是，最后这个区间数量就包含了 _x_。

    注意，_B_ 元素的处理顺序保证了每个区间的终止值在区间的起始值之前得到处理，这对我们处理的右侧半开放区间的情况非常必要。

<pre>
def max_interval_intersec(S):
    B = ([(left,  +1) for left, right in S] +
         [(right, -1) for left, right in S])
    B.sort()
    c = 0
    best = (c, None)
    for x, d in B:
        c += d
        if best[0] &lt; c:
            best = (c, x)
    return best
</pre>

#### 1.6.4　贪婪算法

我们在这里要介绍一种构成贪婪算法的主要算法技巧。笼统来说，这种算法在寻找解决方案的每个步骤中都选择了一个让局部结果最大化的参数。比较正式的说法是，这种算法通过拟阵组合结构，能够证明贪婪算法的优化和不优化程度。我们在本节就不对此展开讨论了（见参考文献 [21]）。

*   例子：最小点积

    我们使用一个简单的例子来介绍这种算法。对于两个给定的向量 _x_ 和 _y_，它们均由 _n_ 个正整数或空组成，首先需找到一种元素的排列 π{1,…, _n_}，使得 ![\sum_i x_iy_{\pi(i)}](http://private.codecogs.com/gif.latex?\sum_i%20x_iy_{\pi(i%29}) 最小。

*   应用

    假设以映射方式将 _n_ 项任务交给 _n_ 个工人完成，也就是说，每项任务必须分别分配给不同的工人。每项任务都有一个完成小时数，每个工人都有一个按每小时计算的工资数。目标是，找到一种排列方式，使得支付给工人的工资总数最少。

*   时间复杂度为 _O_(_n_log_n_) 的算法

    既然最佳解决方案是对 _x_ 和 _y_ 采用同一种排列，在不失普适性的情况下，我们可以假设 _x_ 已经按升序排列好。假设有一个答案把 _x_<sub>0</sub> 和一个最大元素 _y<sub>j</sub>_ 相乘，对于下标 _k_ 且当 _y<sub>i</sub>_ ＜ _y<sub>j</sub>_ 时，有一个确定排序π，使得π(0) = _i_ 且π(_k_) = _j_。我们会发现，_x_<sub>0</sub>_y<sub>i</sub>_ + _x<sub>k</sub>y<sub>j</sub>_ 大于或等于 _x_<sub>0</sub>_y<sub>j</sub>_ + _x<sub>k</sub>y<sub>i</sub>_，这意味着，在没有额外成本的情况下，π可以变换为 _x_<sub>0</sub> 乘以 _y<sub>i</sub>_。证明过程如下，注意这里的 _x_<sub>0</sub> 和 _x<sub>k</sub>_ 都是正数或为空。

    ![enter image description here](https://images.gitbook.cn/c89a5380-d1d0-11e8-b949-eb29383f10ad)

    通过重复操作截断参数，从 _x_<sub>0</sub> 中截断出向量 _x_，并从 _y<sub>j</sub>_ 中截断出向量 _y_，我们发现，当 _i_ → _y_<sub>π(_i_ )</sub> 且 _y_<sub>π(_i_ )</sub> 为逆序的时候，结果最小。

<pre>
def min_scalar_prod(x, y):
    x = sorted(x) # 得到排好序的副本
    y = sorted(y) # 提前准备参数
    return sum(x[i] * y[-i - 1] for i in range(len(x)))
</pre>

#### 1.6.5　动态规划算法

动态规划算法如同程序员随身携带的瑞士军刀，是一项必备的工具。其思路是把问题分解成若干子问题，并基于子问题的解决方案找到原始问题的最优解。

一个经典例子就是计算斐波那契数列第 _n_ 个数的算法。斐波那契数列以如下递归方式定义：

_F_(0)=0

_F_(1)=1

_F_(_i_)=_F_(_i_-1)+_F_(_i_-2)

比如在我们爬楼梯的时候，这个算法可以计算在一次登上 1 或 2 级台阶的情况下，登上 _n_ 级台阶有多少种走法。使用递归方式计算 _F_ 效率很低，因为对于相同的参数 _i_，_F_(_i_) 需要进行多次计算（图 1.6）。而以动态规划算法作为解决方案时，只需简单地把 _F_(0) 到 _F_(_n_) 的数值储存在一个大小为 _n_ ＋ 1 的数组中，并按照下标升序填充数组。如此一来，在计算 _F_(_i_) 时，_F_(_i_–1) 和 _F_(_i_–2) 的值已经被计算好，并存储在数组相应的位置上。

![{98%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/007.png)

图 1.6　左边使用树状结构的穷举法实现斐波那契数列 _F_(4) 的计算过程。右边采用动态规划算法计算依赖值 {14[即计算 _F_(_i_) 时候的 _F_(_i_–1) 和 _F_(_i_–2)。——译者注]} 的方式构成了一个有向无环图，大幅减少了节点数量 {15[左图中每个非叶子节点的值都是通过两个子节点的值计算得来，相同值的节点被多次重复计算；而右图采用动态规划算法，每个节点仅需被计算一次，减少了重复计算的次数。——译者注]}

#### 1.6.6　用整数编码集合

这是一种用一群集合编成整数的高效算法，集合中元素都是介于 0 至 _k_ 的 63 次幂 {16[这个数字是来自 Python 的整数。由于 Python 的整数一般存储在一个机器字中，而这个机器字的长度如今一般是 64 个二进制位。]} 范围内的整数。更准确地说，是使用二进制转换的方式把子集编码成特征向量。编码方式如下表所示。

表 1.2

<table>
<thead>
<tr>
<th>值</th>
<th>表达式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>{}</td>
<td>0</td>
<td>空集</td>
</tr>
<tr>
<td>{i}</td>
<td>1 &lt;&lt; i</td>
<td>这个值代表 2<sup>i</sup></td>
</tr>
<tr>
<td>{0, 1,…,_n_-1}</td>
<td>(1 &lt;&lt; n) - 1</td>
<td>2<sup>n</sup> - 1=2<sup>0</sup> + 2<sup>1</sup> + … + 2<sup>n - 1</sup></td>
</tr>
<tr>
<td>A ∪ B</td>
<td>A | B</td>
<td>管道运算符 | 代表二进制或</td>
</tr>
<tr>
<td>A ∩ B</td>
<td>A &amp; B</td>
<td>与运算符 &amp; 代表二进制与</td>
</tr>
<tr>
<td>(A \ B) ∪ (B \ A)</td>
<td>A ^ B</td>
<td>按位异或运算符 ^ 代表异或</td>
</tr>
<tr>
<td>A ⊆ B</td>
<td>A &amp; B == A</td>
<td>测试是否包含</td>
</tr>
<tr>
<td>i ∈ A</td>
<td>(1 &lt;&lt; i)&amp; A</td>
<td>测试是否属于集合</td>
</tr>
<tr>
<td>{min A}</td>
<td>-A &amp; A</td>
<td>如果 A 为空，此表达式值为 0</td>
</tr>
</tbody>
</table>

图 1.7 中给出了最后一个表达式的证明过程。这个表达式在循环计算一个集合的基数 {17[即集合中包含元素的个数。——译者注]} 时非常有用。但不存在等价算式来获取集合的最大值。

![{98%}](http://www.ituring.com.cn/figures/2018/ProgrammationEfficace/008.png)

图 1.7　获取集合的最小值

我们来看一个经典问题如何应用这一编码技巧。

*   例子：平均分三份

    定义

    假设有 _n_ 个整数 _x_<sub>0</sub>,…, _x_<sub>_n_-1</sub>，现要把这些数平均分配到 3 个集合中，且每个集合中的整数和相同。

    穷举方式时间复杂度为 _O_(2<sup>2_n_</sup>) 的贪婪算法

    思路是枚举所有不相交子集 _A_, _B_ ⊆ {0,…, _n_-1}，并比较 _f_ (_A_)、_f_ (_B_)、_f_ (_C_)，其中 _C_ = {0,…, _n_-1}\_A_\_B_ 且 ![f(S)=\sum_{i\in S}x_i](http://private.codecogs.com/gif.latex?\inline%20f(S%29=\sum_{i\in%20S}x_i)。这种实现方式不需要维护和比较 C 集合，只需证明 _f_(_A_) = _f_(_B_) 且 3_f_(_A_) = _f_({0,…, _n_-1})。

<pre>
def three_partition(x):
    f = [0] * (1 &lt;&lt; len(x))
    for i in range(len(x)):
        for S in range(1 &lt;&lt; i):
            f[S | (1 &lt;&lt; i)] = f[S] + x[i]
    for A in range(1 &lt;&lt; len(x)):
        for B in range(1 &lt;&lt; len(x)):
            if A & B == 0 and f[A] == f[B] and 3 * f[A] == f[-1]:
                return(A, B, ((1 &lt;&lt; len(x)) -1) ^ A ^ B)
    return None
</pre>

这种算法还有另一种应用：使用四则运算来计算指定值（见 15.5 节）。

#### 1.6.7　二分查找

*   定义

    假设 _f_ 是一个布尔函数，即值在 {0, 1} 范围内的函数，且有如下规律：

    ![f(0)\leqslant\cdots\leqslant f(n-1)=1](http://private.codecogs.com/gif.latex?f(0%29\leqslant\cdots\leqslant%20f(n-1%29=1)

    现在要找到最小的实数 _k_ 使得 _f_(_k_) = 1。

*   时间复杂度为 _O_(log_n_) 的算法

    在一个区间 [_l_, _h_] 中查找，起初 _l_ = 0，_h_ = _n_-1。然后用区间的中间值 _m_ = [(_l_ + _h_)/2] 来测试函数 _f_。根据前面的计算结果，查找空间缩小为 [_l_, _m_] 或 [_m_+1, _h_]。注意，在计算 _m_ 的时候向下取整，这样，第二个区间就永远不会为空，第一个区间也是。在 [log<sub>2</sub>(_n_)] 次迭代后，即查找区间缩小为单元素的时候，查找会结束。

<pre>
def discrete_binary_search(tab, lo, hi):
    while lo &lt; hi:
        mid = lo + (hi - lo) // 2
        if tab[mid]:
            hi = mid
        else:
            lo = mid + 1
    return lo
</pre>
*   类库

    Python 标准模块 bisect 中提供了二分查找算法，所以在某些情况下，我们不需要自己来实现。假设有一个数组 tab，由 _n_ 个已排序好的元素组成。现在要为新元素 _x_ 找到插入点 {18[插入的位置要满足排序规则。——译者注]}，那么需要执行 `bisect_left(tab, x, 0, n)`，而其返回值就是第一个满足 tab[_i_] ≥ _x_ 的数组元素的下标 _i_。

*   连续域

    这种技术同样可以用在以下情况：函数 _f_ 的区间为连续，且希望找到最小值 _x_<sub>0</sub>，使得对于所有 _x_ ≥ _x_<sub>0</sub>，都有 _f_ (_x_) = 1。此时，时间复杂度取决于 _x_<sub>0</sub> 需要的精确度。

<pre>
def continuous_binary_search(f, lo, hi):
    while hi - lo > 1e-4:            # 这里设定精确度
        mid = (lo + hi) / 2.         # 浮点数除法<sup>18</sup>
        if f(mid):
            hi = mid
        else:
            lo = mid
    return lo
</pre>
*   无上界的连续域查找

    假设 _f_ 是一个单调布尔函数，_f_(0) = 0，且保证存在整数 _n_，使得 _f_(_n_) = 1。最小的整数 _n_<sub>0</sub> 使得 _f_(_n_<sub>0</sub>) = 1，即使不存在查找所需要的上限，也可以在时间 _O_(log_n_<sub>0</sub>) 内找到 _n_<sub>0</sub> {19[单调函数又称增函数或减函数。这里的布尔函数 _f_ 的值从 0 增加到 1，因此是增函数。如果 _n_<sub>0</sub> 是使 _f_(_n_<sub>0</sub>)=1 的最小值，对于单调函数 _f_ 一定存在一个 _n_<sub>1</sub>＞_n_<sub>0</sub>，有 _f_(_n_<sub>1</sub>) = 1，且 _n_<sub>0</sub> 和 _n_<sub>1</sub> 间的所有值 _n<sub>x</sub>_ 都有 _f_(_n<sub>x</sub>_)=1，这就很容易找到 _n_<sub>0</sub>。——译者注]}。起初，我们设 _n_ = 1；当 _f_(_n_) = 0 时，我们把 _n_ 翻倍。一旦找到整数 _n_ 使得 _f_(_n_) = 1 时，我们就采用通常的二分查找方法。

*   三分查找

    假设函数 _f_ 在 {0,…, _n_-1} 区间内先递增，后递减，而我们要找到其中的最大值。在这种情况下，把查找区间 &#91;_l_, _h_] 拆分成三块，即 &#91;_l_, _a_]、&#91;_a_+1, _b_] 和 &#91;_b_+1, h]，这样比拆成两块更简单。通过比较 _f_(_a_) 和 _f_(_b_) 的值，可以判断 &#91;_l_, _b_] 和 &#91;_a_+_l_, _h_] 中的哪个区间包含要找的最大值。这种算法需要的迭代次数是对数 log<sub>3/2</sub>_n_。{20[注意，比较_f_(_a_) 和_f_(_b_) 后迭代查找的区间不是最开始拆分开的左、中、右三个区间中的一个，而是左 + 中或中 + 右两个区间中的一个。画个图就很容易理解了。——译者注]}

*   在区间 [0, 2<sup>_k_</sup>) 中的查找

    如果查找区间的大小 _n_ 是 2 的幂，仅使用位操作中的位移运算和异或运算，就可以对普通二分查找进行少许优化。我们从数组的最后一个元素的下标开始。这个元素的二进制格式是长度为 _k_ 的一列 1。对于每个要测试的二进制位，我们把它替换成 0，即可得到用于遍历整个数组的下标 _i_，而测试 tab[_i_] 的真伪，即可完成查找。

<pre>
def optimized_binary_search(tab, logsize):
    hi = (1 &lt;&lt; logsize) - 1
    intervalsize = (1 &lt;&lt; logsize) >> 1
    while intervalsize > 0:
        if tab[hi ^ intervalsize]:
            hi ^= intervalsize
        intervalsize >>= 1
    return hi
</pre>
*   逆函数

    对于连续且严格单调函数 _f_，一定存在一个逆函数 _f_ <sup>-1</sup>，后者也是单调的。假设函数 _f_ <sup>-1</sup> 的计算比函数 _f_ 简单许多，当给定一个值 _x_ 的时候，我们可以借它来完成对 _f_ (_x_) 的计算。其实，只要找到最小值 _y_ 使得 _f_ <sup>-1</sup>(_y_) ≥ _x_ 就可以了 {21[这里还是在说找单调函数里面最小最大值的问题。——译者注]}。

*   例子：填充蓄水池

    某个连通容器系统由 _n_ 个瓶壁高度不同的容器互相连通组成，我们想计算将系统的液位提升到一个指定高度所需注入的水量。或者，假设向系统中注入体积为 _V_ 的液体，想确定系统的液面高度，可以使用以下方式 {22[这里调用的 `continuous_binary_search` 方法是在前文“连续域查找”中定义的，可以理解为先往容器系统中倾倒液体，多了就减半再试，少了就加一半再试，直到找到符合精确度的液体量。 ——译者注]}：

<pre>
level = continuous_binary_search(lambda level: volume(level) >= V, 0, hi)
</pre>

### 1.7　建议

我们在这里给出一些建议，帮助读者更快解决算法问题，并写出正确的程序。首先，要学会有组织、成体系地思考。为此，一定不要在尚未清楚理解题目的所有细节之前，仅凭一时冲动就开始编写程序。如果你在拿起键盘之前先冷静地审视一下，就不会轻易犯下某些错误，否则，你很容易写出一个根本无法实现的方案。

如果有可能，最好在竞赛时把读题和解题的时间分开。多给自己一点时间。在程序代码的注释中添加问题描述，如果有可能，再加上题目的 URL，并明确指出算法的时间复杂度。在一段时间后，当你回头再看自己编写的程序时，一定会欣赏这种做法。尤其，这能让程序代码保持逻辑严密、结构紧凑。尽量使用题目中提到的名词，以便显示答案和题目的相关性，因为没有什么比调试变量名更没有实际意义、更让人难受的事情了。

*   好好读题

    什么样的时间复杂度可以被接受？

        注意题目中提出的限制，在实现你的算法之前做好复杂度分析。

    输入数据是否有条件、有保证？

        不要从题目的例子中猜测条件。不要做任何猜测。如果题目中没有说明“图是非空的”，那么某些测试用例中就有可能包含空的图。如果题目中没有说“字符串不包含空格”，那么就可能有一个测试用例包含这样的字符串。

    使用什么样的数据类型？

        整数还是浮点数？数字是否有可能是负值？如果你使用 Java 或 C++ 写程序，注意要确定中间变量的上限值，选择使用 16 位、32 位或 64 位的整数。

    哪道问题更简单？

        对于一个需要完成几个问题的竞赛，你应当在开始时快速浏览所有题目，分析每道题目的类型，是贪婪算法、隐式图还是动态规划算法？而后评估题目的难度。把精力集中在那些最简单且优先级最高的题目上。在团体竞赛的时候，要根据每个参赛者的专业程度来分配题目。留意其他队伍的进度，也能帮你发现容易解决的简单题目。

*   做好计划

    比较题目的例子

        画纲要图。找到待解决问题与已知问题之间的关联，如何利用实例的特殊性？

    如果可能，利用类库

        掌握经典的二分查找算法、排序和字典等类库。

    使用题目中提到的名词命名变量

        名词越简短、表述越清晰越好。

    初始化变量

        确保在任何新测试用例使用前，所有变量已经被重新初始化。继续上一个未完成的迭代是一个很典型的错误。举例来说，一个程序解决了图的问题，输入中包含了很多个测试用例。每个测试用例以两个整数开始：顶点数量 _n_ 和道路数量 _m_。接着是两个大小都是 _m_ 的整数组 _A_ 和 _B_，其中保存了每个用例中道路的顶点。假设我们使用邻接链表来编辑一个图，对于每个 _i_ = 0,…, _m_-1，把 _B_[_i_] 与 _G_[_A_[_i_]] 相加，把 _A_[_i_] 与 _G_[_B_[_i_]] 相加。如果链表没有在每次读入测试用例前被清空，题目中的路径会累积在一起，形成一个所有图的交集。

*   调试

    现在犯错

        为了以后有正确的反应 {23[平时多调试，多看错误信息，积累定位错误的灵感。——译者注]}。

    设定和测试更多的测试用例

        对于有限制条件的情况（裁判回复“错误答案”）{24[此时一般没有检查边界条件。——译者注]} 和输入数据很多的情况（裁判回复“答题超时”或“运行时错误”）{25[此时一般是有了死循环和除 0 错误。——译者注]}，设定更多测试。

    解释算法

        解释自己的算法，并向队友评论程序。你必须能解释清楚每一行代码。

    简化实现

        把相似代码重新组织和重构。

    冷静审视

        先跳转到另一道问题上，然后回头再看，以获得新的视角。

    比较

        比较你的本地开发环境和要运行代码的服务器环境。

### 1.8　走得更远

以下推荐的作品，能帮你更深入地理解本书涉及的内容。

*   基础算法：《算法导论（第 3 版）》(T.H. Cormen, C.E. Leiserson, R.L. Rivest, and C. Stein, The MIT Press: Cambridge, 2009)。
*   更特殊算法：_Encyclopedia of Algorithms_ (Editors: Ming-Yang Kao, Springer Verlag, 2008)。
*   流算法相关深入、广泛的研究：《网络流：理论、算法与应用》(R.K. Ahuja, T.L. Magnanti and J.B. Orlin, Prentice Hall, 2011)。
*   几何算法：_Computational Geometry: Algorithms and Application_ s (M. de Berg, O. Cheung, M. van Krevel and M. Overmars, Springer Verlag, 2011)。
*   其他广受欢迎的参考书：_Python Essential Reference_ (David M. Beazley, Pearson Education, 2009) 和《Python cookbook，第三版》（David M. Beazley, Brian K. Jones，人民邮电出版社， 2015 年）。
*   对于准备竞赛很有帮助的书：_Competitive Programming_ (Steven and Felix Halim, Lulu, 2013)。
*   最后是《算法设计指南》（Steven S. Skiena, Springer Verlag, 2009 年）。

本书最后给出了书中提及的参考文献，其中包含了图书和科研论文。但对于大众来说，论文并不容易接触到。读者可以通过 Google Scholar 或在大学图书馆里尝试寻找这些文献的原文。

阅读本书有时需要配合使用网站 [tryalog.org/index-en](http://tryalog.org/index-en)。在这里，读者不但能找到本书中编写的 Python 程序，还能找到测试用例的文件。当然，这些程序和文件也可以在 Github 和 PyPI 仓库中找到，在 Python 3 环境下使用命令 pip install tryalgo 就可以一步安装。
