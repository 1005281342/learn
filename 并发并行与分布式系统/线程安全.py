"""
线程安全就是多线程访问时，采取了加锁的机制，
当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问知道该线程读取完，其他的线程才可使用，不会出现数据不一致或数据污染的问题
线程不安全就是不提供数据访问保护，有可能出现多个线程现后更改数据造成所得到的数据是脏数据。
总的来说，只要线程之间没有共享资源，那么就是线程安全的，有共享资源，为了保证线程安全，需要引进锁的机制。


一些支持 线程安全的数据结构或原子操作
    list的pop, append

    Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。
    虽然 list 对象也支持类似操作，不过这里优化了定长操作和 pop(0) 和 insert(0, v) 的开销。
    它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。


使用threading给多线程加锁
    #创建锁
    mutex = threading.Lock()
    #锁定
    mutex.acquire([timeout])
    #释放
    mutex.release()

    好几个人问我给资源加锁是怎么回事，其实并不是给资源加锁, 而是用锁去锁定资源，
    你可以定义多个锁, 当你需要独占某一资源时，任何一个锁都可以锁这个资源，
    就好比你用不同的锁都可以把相同的一个门锁住是一个道理。


“锁”的问题，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期。


解决死锁

    使用多进程+协程

    死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共同话题一样）。

    根据经验来讲，尽可能保证每一个线程只能同时保持一个锁，这样程序就不会被死锁问题所困扰。

    一旦有线程同时申请多个锁，一切就不可预料了。
    死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。

    一个比较常用的死锁检测与恢复的方案是引入看门狗计数器。

    当线程正常 运行的时候会每隔一段时间重置计数器，在没有发生死锁的情况下，一切都正常进行。
    一旦发生死锁，由于无法重置计数器导致定时器 超时，这时程序会通过重启自身恢复到正常状态。
    避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。
    避免死锁的主要思想是，单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。
    下面以一个关于线程死锁的经典问题：“哲学家就餐问题”，作为本节最后一个例子。
    题目是这样的：五位哲学家围坐在一张桌子前，每个人 面前有一碗饭和一只筷子。在这里每个哲学家可以看做是一个独立的线程，而每只筷子可以看做是一个锁。
    每个哲学家可以处在静坐、思考、吃饭三种状态中的一个。需要注意的是，每个哲学家吃饭是需要两只筷子的，
    这样问题就来了：如果每个哲学家都拿起自己左边的筷子， 那么他们五个都只能拿着一只筷子坐在那儿，直到饿死。此时他们就进入了死锁状态。
"""
